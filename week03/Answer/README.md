## Codyssey DMU 1주차 문제

### 필수 단계1: 이별은 화성, 잊고 있었던 고마운 것들 - 동양미래대 문제 내역

https://jakdalmak-work.notion.site/Codyssey-3-6-1c6f6bbbe13c80468d7dfb7efb8ec042

### 풀이자에게 전달 사항

- 과제 수행 목록 관련

```
- 더미 센서에 해당하는 클래스 이름을 DummySensor로 정의 완료
- DummySensor의 멤버로 env_values라는 딕셔너리 객체를 추가 완료.
- DummySensor 클래스에 set_env() 메소드를 추가하여 random으로 주어진 범위 안의 값을 생성해서 env_values 항목 채우도록 설계 및 구현 완료.
- DummySensor 클래스에 get_env() 메소드 추가하여 env_values를 return 하도록 구현 완료.
- DummySensor 클래스를 ds라는 이름으로 인스턴스(Instance)로 제작 완료.
- 인스턴스화 한 DummySensor 클래스에서 set_env()와 get_env()를 차례로 호출해서 값을 확인 구현 완료.
- 전체 코드를 mars_mission_computer.py 파일로 저장 완료.
```

- 추가과제 1 - 시간 값 가져와 DummySensor 랜덤값 연계하여 로그 파일 작성하기
  시간값 가져오는 과정은 get_time_with_ctypes.py 모듈의 stamp_time_with_ctypes() 메소드 참조해주세요.
  로그파일의 작성은 DummySensor 내부 메소드인 set_env()에 위치해있습니다.
  생성 및 수정된 로그파일의 이름은 SensorData.log입니다.

### 구현 내역 상세 설명

비대면으로 평가하시는 분을 위해 부득이하게 상세히 작성하였습니다.

1. \_\_slots\_\_의 사용 사유
   파이선은 자바와 다르게 instance에 대해 자유롭게 필드의 추가가 가능합니다.
   이를 위해 파이선은 객체 내에 \_\_dict\_\_라는 내부 딕셔너리를 지니고 있으며,
   이 딕셔너리를 이용해 객체의 모든 필드를 확인 및 동적으로 할당(추가) 및 수정하도록 할 수 있습니다.

   그러나 본 DummySensor 클래스는 아래와 같은 사유로 이러한 기능들이 낭비라고 판단했습니다.

   1-1. DummySensor의 유지보수 시, 구태여 별도의 필드가 추가될 이유가 없습니다. 센서 기종을 변경할 경우 취급하는 수집 데이터가 변경될 수는 있으나, 해당 데이터 자체가 클래스의 필드 변수인 env_values 딕셔너리 내부에서 다루어지는 만큼 DummySensor라는 클래스 자체는 고정적인 필드 목록을 지녀도 무방합니다.
   1-2. 본 코드는 \_\_dict\_\_를 이용한 동적 변환 등의 기능을 사용하지 않습니다.
   1-3. 센서를 다루기 위한 본 객체에 필드의 추가 등이 발생할 경우 이를 DTO 등 서비스에서 활용하고자 할 때 문제가 발생할 수 있습니다.(물론 DTO는 보통 따로 만들겠지만...)

   위의 사유(속성의 동적 추가 제한) 및 메모리 절약(딕셔너리를 제거하므로 객체에 할당된 주소 범위가 더 작아짐)을 목적으로 활용했습니다.

2. 필드 변수명 앞에 '\_'가 위치한 이유 && Property(fget, fset, fdel=None, doc=None) 객체의 사용 이유
   본 클래스의 유지보수 및 확장성을 고려할 때, setter와 getter의 설정은 필수적입니다. 또한 private, public과 같은 접근제어자를 설정하여 클래스를 활용한 기능 구현 시에 문제의 소지가 없도록 해야할 것입니다.

   2-1. 변수명 앞의 \_, \_\_는 접근제어자 지정을 위함이다!!!

   파이선에서는 다음과 같은 표기를 권장하고 있습니다.
   private / protected / public으로 나뉘며, private 목적의 변수명 앞에는 \_\_를, protected 목적의 변수명 앞에는 \_를 붙이기를 권장합니다. public에는 별도의 설정하지 않구요.
   자바처럼 시스템 적인 면에서 필드 변수(멤버 변수)에 대한 내부/외부 접근에 대해 강제하는 목적이며 시스템적으로 접근 불가를 강제합니다.
   이로 인해 추후 유지보수 시 본인/타인이 본 코드 수정 시 참조 목적으로, \*를 붙여 내부 필드 변수들을 private로 사용하도록 설정했습니다.

   2-1-1. 실제로는 protected에는 시스템적인 강제성이 없습니다. \_는 그냥 개발자들 간의 약속으로 이해하기!
   2-1-2. 사실 파이선의 private는 자바의 private와 본질적으로 다릅니다. 시스템적인 강제성보다는 정확히는.. 이름을 바꿔치기 하는 느낌이라고 합니다.(mangling이라고 부른답니다.)
   그래서 사실 private 필드나 메소드에 대해서 인스턴스명.\_클래스명\_\_private변수/메소드명 과 같이 접근해서 외부에서도 사용할 수 있다고 합니다. 접근 방식이 복잡해서 진짜 어거지로 필요할때는 또 쓸 수 있게 만들어둔 느낌?

   2-2. Property() 객체를 이용해 getter, setter의 구현이 가능하다!
   본 클래스는 굉장히 많은 필드 변수를 가지고 있습니다.(정확히는 필드변수인 env_values 딕셔너리의 key-value 쌍이 많다고 봐야하긴 합니다만..)
   이러한 변수들에 대해 일일히 getter, setter를 작성한다면 코드 줄을 엄청나게 소모해서 가독성이 떨어지게 됩니다.
   또한 본 코드에서 사용했듯 기입/수정된 필드 값에 대한 조건 확인까지 수행한다면 가독성이 더더더 떨어지구요.

   이러한 getter, setter와 같은 내역을 JAVA에서는 Lombok 라이브러리를 이용하여 @Getter, @Setter와 같은 방식으로 처리하여 해결합니다. property() 객체는, 바로 이러한 getter, setter 구현에 사용되는 일종의 롬복이라고 보시면 됩니다.

   ```
   사용할프로퍼티객체명 = Property(fget, fset, fdel=None, doc=None)
   ```

   - fget == getter 설정 목적의 메소드 내역 기입
   - fset == setter 설정 목적의 메소드 내역 기입
   - fdel == 객체 내 필드 값을 제거(\_\_slots\_\_이 걸려있어도 삭제에는 이상 XXX)
   - fget == 본 Property 객체가 어떠한 목적인지에 대해 설명 str을 기입.

   과 같이 설정되어있는 객체입니다.

   즉, `사용할프로퍼티객체명.필드변수명 = 변수값` 을 사용하면 fset에 할당되었던 setter 메소드가 자동 사용되고, `print(사용할프로퍼티객체명.필드변수명)` 과 같이 값의 반환이 필요한 양식을 사용하면 fget에 할당되었던 getter 메소드가 자동 사용됩니다.
   이때 유의할 것은, Property를 이용해 생성한 객체는 \_\_init\_\_의 내부가 아니라 class의 내부에 위치해있어야 한다는 점이 있습니다. 또한 이렇게 할당한 property 기반 객체는 변환할 필드 당 1개씩을 설정하는 방식입니다. env_values 딕셔너리의 내부 key 값 별로 property를 할당한 이유가 이것입니다.

   최종적으로 적어도, getter setter를 일일히 작성하는것보다는 짧고 간편하며, 관리하기 편하도록 설계되었습니다.
   참고, '데코레이터'라는 이름으로 Lombok의 어노테이션과 비슷하게 property를 사용하는 방식이 있습니다. 본 코드는 데코레이터를 사용하지 않고 코드로 구현한 것이라고 봐주시면 됩니다.(데코레이터가 lombok만큼 코드를 자동화해주는건 아닌거같습니다.)

3. 시간 값을 가져오는 방법
   시간 값을 가져오는 방법으로는 datetime, time 모듈의 사용 등이 있습니다.
   이때 datetime은 time 모듈을 참조하므로, 실질적으로 time 모듈이 사용됩니다.
   그러나, 이 time 모듈 역시 내부적으로는 c의 라이브러리를 불러와 시간값을 얻어 제공해주는 식입니다. 즉, 파이선은 기본 모듈을 사용하지 않는 이상 시간 값을 가져올 방법이 없습니다.(c 라이브러리를 불러와야 하기 때문)

   본 코드는 time 모듈을 그대로 사용하는 대신, ctypes 모듈을 이용해 직접적으로 time 모듈이 시간값을 어떻게 불러오는지를 비슷하게 구현해봤습니다.

   ctypes에 대한 내용은 코드 별로 하나하나 설명해야하므로 README가 지나치게 길어질 수 있어, get_time_with_ctypes.py 파일의 주석들을 확인해주시기 바랍니다.

### 풀이 관련 내역

현재 Pass 횟수 : 2 - 완료

비고 :
교수님께 지적받은 사항.

1. 파이선의 접근제어자는 시스템적으로 접근 가능/불가 여부를 결정하는게 맞고, protected 목적의 '\_'만 시스템이 제어하지 않습니다. => 본 글 수정 완료. 다만 파이선의 private은 우회 접근 방식 있어서 기재하였음.
2. **(이름)** 라는 변수는 '매직변수'라고 부릅니다!
